'use strict';

var clientFetch = require('@hey-api/client-fetch');

const client = clientFetch.createClient(clientFetch.createConfig());
const handleDeployCloudstate = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/cloudstate/v1/deploy"
  });
};
const handleBackupCloudstate = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/cloudstate/v1/projects/{id}/backup"
  });
};
const handleVerifyWildcard = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/domains/v1/certs/{domain}/wildcard"
  });
};
const handleListDomains = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/domains/v1/domains"
  });
};
const handleListDomainVerificationRequests = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/domains/v1/verifications"
  });
};
const handleVerifyDomain = (options) => {
  return (options?.client ?? client).put({
    ...options,
    url: "/domains/v1/verifications"
  });
};
const handleCreateDomainVerification = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/domains/v1/verifications"
  });
};
const handleDeleteDomainVerification = (options) => {
  return (options?.client ?? client).delete({
    ...options,
    url: "/domains/v1/verifications"
  });
};
const handleEphemeralDevServer = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/ephemeral/v1/dev-servers"
  });
};
const handleListExecuteRuns = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/execute/v1/deployments"
  });
};
const handleGetExecuteRun = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/execute/v1/deployments/{deployment}"
  });
};
const handleExecuteScript = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/execute/v1/script"
  });
};
const handleCreateIdentity = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/git/v1/identity"
  });
};
const handleDeleteIdentity = (options) => {
  return (options?.client ?? client).delete({
    ...options,
    url: "/git/v1/identity/{identity}"
  });
};
const handleListPermissions = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/git/v1/identity/{identity}/permissions"
  });
};
const handleDescribePermission = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/git/v1/identity/{identity}/permissions/{repo}"
  });
};
const handleGrantPermission = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/git/v1/identity/{identity}/permissions/{repo}"
  });
};
const handleRevokePermission = (options) => {
  return (options?.client ?? client).delete({
    ...options,
    url: "/git/v1/identity/{identity}/permissions/{repo}"
  });
};
const handleUpdatePermission = (options) => {
  return (options?.client ?? client).patch({
    ...options,
    url: "/git/v1/identity/{identity}/permissions/{repo}"
  });
};
const handleListGitTokens = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/git/v1/identity/{identity}/tokens"
  });
};
const handleCreateGitToken = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/git/v1/identity/{identity}/tokens"
  });
};
const handleRevokeGitToken = (options) => {
  return (options?.client ?? client).delete({
    ...options,
    url: "/git/v1/identity/{identity}/tokens"
  });
};
const handleListRepositories = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/git/v1/repo"
  });
};
const handleCreateRepo = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/git/v1/repo"
  });
};
const handleDeleteRepo = (options) => {
  return (options?.client ?? client).delete({
    ...options,
    url: "/git/v1/repo/{repo}"
  });
};
const handleListGitTriggers = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/git/v1/repo/{repo}/trigger"
  });
};
const handleCreateGitTrigger = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/git/v1/repo/{repo}/trigger"
  });
};
const handleDeleteGitTrigger = (options) => {
  return (options?.client ?? client).delete({
    ...options,
    url: "/git/v1/repo/{repo}/trigger/{trigger}"
  });
};
const handleGetLogs = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/observability/v1/logs"
  });
};
const handleDeployWebV2 = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/web/v1/deployment"
  });
};
const handleListWebDeploys = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/web/v1/deployments"
  });
};

class FreestyleSandboxes {
  client;
  constructor(options) {
    if (typeof Deno !== "undefined") {
      class FreestyleRequest extends Request {
        constructor(input, init) {
          if (init.client !== void 0) {
            console.warn("Unsupported client detected, using default client");
            delete init.client;
          }
          super(input, init);
        }
      }
      Request = FreestyleRequest;
    }
    this.client = clientFetch.createClient({
      baseUrl: options.baseUrl ?? "https://api.freestyle.sh",
      headers: {
        Authorization: `Bearer ${options.apiKey}`,
        ...options.headers
      }
    });
  }
  /**
   * Execute a script in a sandbox.
   */
  async executeScript(script, config) {
    const response = await handleExecuteScript({
      client: this.client,
      body: {
        script,
        config
      }
    });
    if (response.data) {
      return response.data;
    }
    throw {
      message: `Failed to execute script: 

${script}

Error:

${JSON.stringify(
        response
      )}`,
      error: response.error
    };
  }
  /**
   * Deploy a Web project to a sandbox.
   */
  async deployWeb(source, config) {
    const response = await handleDeployWebV2({
      client: this.client,
      body: {
        source,
        config
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to deploy web project

Status: ${response.response.status}

Message: ${response.error?.message}`
    );
  }
  /**
   * Deploy a Cloudstate project to a sandbox.
   */
  async deployCloudstate(body) {
    const response = await handleDeployCloudstate({
      client: this.client,
      body
    });
    if (response.data) {
      return response.data;
    }
    throw new Error("Failed to deploy Cloudstate project");
  }
  /**
   * Get a backup of a Cloudstate project in a sandbox.
   * @param id The ID of the Cloudstate project.
   * @returns The backup of the Cloudstate project.
   * @throws An error if the backup could not be retrieved.
   */
  async backupCloudstate(id) {
    const response = await handleBackupCloudstate({
      client: this.client,
      path: {
        id
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error("Failed to get backup of Cloudstate project");
  }
  /**
   * Get logs for an execute run, or web deployment.
   * @param id The ID of the sandbox.
   * @returns The logs for the sandbox.
   * @throws An error if the logs could not be retrieved.
   */
  async getLogs(id) {
    const response = await handleGetLogs({
      client: this.client,
      query: {
        deploymentId: id
      }
      // path: {
      //   id: id,
      // },
    });
    if (response.data) {
      return response.data;
    }
    throw new Error("Failed to get logs for sandbox");
  }
  /**
   * Create a a domain verification request.
   * @param domain The domain to verify.
   * @returns The domain verification token.
   */
  async createDomainVerificationRequest(domain) {
    const response = await handleCreateDomainVerification({
      client: this.client,
      body: {
        domain
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(response.error.message);
  }
  /**
   * Verify a domain. Note, this requires the domain verification token to be already set up.
   * @param domain The domain to verify.
   * @returns The domain verification request.
   */
  async verifyDomain(domain) {
    const response = await handleVerifyDomain({
      client: this.client,
      body: {
        domain
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to verify domain ${domain}: ${response.error.message}`
    );
  }
  async listDomains() {
    const response = await handleListDomains({
      client: this.client
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(`Failed to list domains
${response.error.message}`);
  }
  async listDomainVerificationRequests() {
    const response = await handleListDomainVerificationRequests(
      {
        client: this.client
      }
    );
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to list domain verification requests
${response.error.message}`
    );
  }
  async deleteDomainVerificationRequest(domain, verificationCode) {
    const response = await handleDeleteDomainVerification({
      client: this.client,
      body: {
        domain,
        verificationCode
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to delete domain verification request for domain ${domain}: ${response.error.message}`
    );
  }
  async listWebDeployments(limit, offset) {
    const response = await handleListWebDeploys({
      client: this.client,
      query: {
        limit: limit ?? 10,
        offset: offset ?? 0
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to list web deployments
${response.error.message}`
    );
  }
  async listExecuteRuns(limit, offset) {
    const response = await handleListExecuteRuns({
      client: this.client,
      query: {
        limit: limit ?? 10,
        offset: offset ?? 0
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(`Failed to list execute runs
${response.error.message}`);
  }
  async getExecuteRun(id) {
    const response = await handleGetExecuteRun({
      client: this.client,
      path: {
        deployment: id
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to get execute run with ID ${id}: ${response.error.message}`
    );
  }
  /** Provision a wildcard certificate for domain. */
  async provisionWildcard(domain) {
    const response = await handleVerifyWildcard({
      client: this.client,
      path: {
        domain
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to provision wildcard for domain ${domain}: ${response.error.message}`
    );
  }
  /**
   * Create a new git repository.
   */
  async createGitRepository({
    name,
    public: pub = false,
    source
  }) {
    const response = await handleCreateRepo({
      client: this.client,
      body: {
        name,
        public: pub,
        source
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to create git repository ${name}: ${response.error}`
    );
  }
  /**
   * List git repositories.
   */
  async listGitRepositories({
    limit = 10,
    offset = 0
  } = {}) {
    const response = await handleListRepositories({
      client: this.client,
      query: {
        limit,
        offset
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(`Failed to list git repositories: ${response.error}`);
  }
  /**
   * Delete a git repository.
   */
  async deleteGitRepository({
    repoId
  }) {
    const response = await handleDeleteRepo({
      client: this.client,
      path: {
        repo: repoId
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to delete git repository ${repoId}: ${response.error}`
    );
  }
  /**
   * Create a new git identity.
   */
  async createGitIdentity() {
    const response = await handleCreateIdentity({
      client: this.client
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(`Failed to create git identity: ${response.error}`);
  }
  /**
   * Delete a git identity.
   */
  async deleteGitIdentity({
    identityId
  }) {
    const response = await handleDeleteIdentity({
      client: this.client,
      path: {
        identity: identityId
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(`Failed to delete git identity: ${response.error}`);
  }
  /**
   * Grant a git identity access to a repository.
   */
  async grantGitPermission({
    repoId,
    identityId,
    permission
  }) {
    const response = await handleGrantPermission({
      client: this.client,
      path: {
        repo: repoId,
        identity: identityId
      },
      body: {
        permission
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to grant access to git identity ${identityId} for repository ${repoId}: ${response.error}`
    );
  }
  /**
   * Update a git identity's permissions on a repository.
   */
  async updateGitPermission({
    repoId,
    identityId,
    permission
  }) {
    const response = await handleUpdatePermission({
      client: this.client,
      path: {
        repo: repoId,
        identity: identityId
      },
      body: {
        permission
      }
    });
    if (response.data) {
      return;
    }
    throw new Error(
      `Failed to update permission for git identity ${identityId} for repository ${repoId}: ${response.error}`
    );
  }
  /**
   * Revoke a git identity's access to a repository.
   */
  async revokeGitPermission({
    repoId,
    identityId
  }) {
    const response = await handleRevokePermission({
      client: this.client,
      path: {
        repo: repoId,
        identity: identityId
      }
    });
    if (response.data) {
      return;
    }
    throw new Error(
      `Failed to revoke access to git identity ${identityId} for repository ${repoId}: ${response.error}`
    );
  }
  /**
   * List access permissions for a git identity.
   */
  async listGitPermissions({
    identityId
  }) {
    const response = await handleListPermissions({
      client: this.client,
      path: {
        identity: identityId
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to list permissions for git identity ${identityId}: ${response.error}`
    );
  }
  /**
   * Get the permission of a git identity on a repository.
   */
  async getGitPermission({
    repoId,
    identityId
  }) {
    const response = await handleDescribePermission({
      client: this.client,
      path: {
        repo: repoId,
        identity: identityId
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to get permission for git identity ${identityId} on repository ${repoId}: ${response.error}`
    );
  }
  /**
   * Create a new git access token for an identity.
   */
  async createGitAccessToken({
    identityId
  }) {
    const response = await handleCreateGitToken({
      client: this.client,
      path: {
        identity: identityId
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to create git access token: ${response.error.message}`
    );
  }
  /**
   * Revoke a git access token.
   */
  async revokeGitAccessToken({
    identityId,
    tokenId
  }) {
    const response = await handleRevokeGitToken({
      client: this.client,
      body: {
        tokenId
      },
      path: {
        identity: identityId
      }
    });
    if (response.data) {
      return;
    }
    throw new Error(
      `Failed to revoke git access token ${tokenId}: ${response.error.message}`
    );
  }
  /**
   * List git access tokens for an identity.
   */
  async listGitAccessTokens({
    identityId
  }) {
    const response = await handleListGitTokens({
      client: this.client,
      path: {
        identity: identityId
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to list git access tokens: ${response.error.message}`
    );
  }
  /**
   * List git triggers for a repository.
   */
  async listGitTriggers({
    repoId
  }) {
    const response = await handleListGitTriggers({
      client: this.client,
      path: {
        repo: repoId
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to list git triggers for repository ${repoId}: ${response.error.message}`
    );
  }
  /**
   * Create a git trigger for a repository.
   */
  async createGitTrigger({
    repoId,
    trigger,
    action
  }) {
    const response = await handleCreateGitTrigger({
      client: this.client,
      path: {
        repo: repoId
      },
      body: {
        trigger,
        action
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to create git trigger for repository ${repoId}: ${response.error.message}`
    );
  }
  /**
   * Delete a git trigger.
   */
  async deleteGitTrigger({ triggerId }) {
    const response = await handleDeleteGitTrigger({
      client: this.client,
      path: {
        trigger: triggerId
      }
    });
    if (response.data) {
      return;
    }
    throw new Error(
      `Failed to delete git trigger ${triggerId}: ${response.error.message}`
    );
  }
  /**
   * Request a dev server for a repository. If a dev server is already running
   * for that repository, it will return a url to that server. Dev servers are
   * ephemeral so you should call this function every time you need a url. Do
   * not store the url in your database!
   */
  async requestDevServer(options) {
    function formatHook(serverUrl, repoUrl) {
      const hook = serverUrl + "/__freestyle_dev_server/update/git?repo=" + encodeURIComponent(repoUrl);
      return hook;
    }
    const response = await handleEphemeralDevServer({
      client: this.client,
      body: {
        ...options,
        // @ts-ignore
        repo: options.repoUrl
      }
    });
    if (response.error) {
      throw new Error(
        // @ts-ignore
        `Failed to request dev server: ${response.error.message}`
      );
    }
    if (response.data.isNew) {
      const rId = options.repoId || options.repoUrl.split("/").at(-1);
      await this.createGitTrigger({
        repoId: rId,
        action: {
          endpoint: formatHook(
            response.data?.url,
            options.repoUrl || `https://git.freestyle.sh/${rId}`
          ),
          action: "webhook"
        },
        trigger: {
          event: "push"
        }
      });
    }
    if (!response.data) {
      throw new Error(`Failed to request dev server: ${response.error}`);
    }
    return {
      ...response.data,
      // @ts-ignore
      mcpEphemeralUrl: response.data.mcpEphemeralUrl || response.data.url + "/mcp",
      ephemeralUrl: response.data.ephemeralUrl ?? response.data.url,
      codeServerUrl: (
        // @ts-ignore
        response.data.codeServerUrl ?? response.data.ephemeralUrl + "/__freestyle_code_server/?folder=/template"
      )
    };
  }
}

exports.FreestyleSandboxes = FreestyleSandboxes;
