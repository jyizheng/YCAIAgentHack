import fs from 'node:fs';
import * as path from 'node:path';
import path__default from 'node:path';
import { createRequire } from 'module';
import * as process from 'node:process';
import { Hono } from 'hono';
import { serveStatic } from 'hono/deno';

const require = createRequire(import.meta.url);
const debug = console.log;
function getProcessedManifest(path2) {
  const routesManifest = JSON.parse(
    fs.readFileSync(path2, "utf-8")
  );
  const parsed = {
    ...routesManifest,
    notFoundRoutes: routesManifest.notFoundRoutes.map((value) => {
      return {
        ...value,
        namedRegex: new RegExp(value.namedRegex)
      };
    }),
    apiRoutes: routesManifest.apiRoutes.map((value) => {
      return {
        ...value,
        namedRegex: new RegExp(value.namedRegex)
      };
    }),
    htmlRoutes: routesManifest.htmlRoutes.map((value) => {
      return {
        ...value,
        namedRegex: new RegExp(value.namedRegex)
      };
    }),
    redirects: routesManifest.redirects?.map((value) => {
      return {
        ...value,
        namedRegex: new RegExp(value.namedRegex)
      };
    }),
    rewrites: routesManifest.rewrites?.map((value) => {
      return {
        ...value,
        namedRegex: new RegExp(value.namedRegex)
      };
    })
  };
  return parsed;
}
function getRoutesManifest(distFolder) {
  return getProcessedManifest(path__default.join(distFolder, "_expo/routes.json"));
}
function createRequestHandler(distFolder, {
  getRoutesManifest: getInternalRoutesManifest,
  getHtml = async (_request, route) => {
    const filePath = path__default.join(distFolder, route.page + ".html");
    if (fs.existsSync(filePath)) {
      return fs.readFileSync(filePath, "utf-8");
    }
    const hoistedFilePath = route.page.match(/\/index$/) ? path__default.join(distFolder, route.page.replace(/\/index$/, "") + ".html") : null;
    if (hoistedFilePath && fs.existsSync(hoistedFilePath)) {
      return fs.readFileSync(hoistedFilePath, "utf-8");
    }
    return null;
  },
  getApiRoute = async (route) => {
    const filePath = path__default.join(distFolder, route.file);
    debug(`Handling API route: ${route.page}: ${filePath}`);
    if (!fs.existsSync(filePath)) {
      return null;
    }
    if (/\.c?js$/.test(filePath)) {
      return require(filePath);
    }
    return import(filePath);
  },
  logApiRouteExecutionError = (error) => {
    console.error(error);
  },
  handleApiRouteError = async (error) => {
    if ("statusCode" in error && typeof error.statusCode === "number") {
      return new Response(error.message, {
        status: error.statusCode,
        headers: {
          "Content-Type": "text/plain"
        }
      });
    }
    return new Response("Internal server error", {
      status: 500,
      headers: {
        "Content-Type": "text/plain"
      }
    });
  }
} = {}) {
  let routesManifest;
  return async function handler(request) {
    if (getInternalRoutesManifest) {
      const manifest = await getInternalRoutesManifest(distFolder);
      if (manifest) {
        routesManifest = manifest;
      } else {
        return new Response("No routes manifest found", {
          status: 404,
          headers: {
            "Content-Type": "text/plain"
          }
        });
      }
    } else if (!routesManifest) {
      routesManifest = getRoutesManifest(distFolder);
    }
    const url = new URL(request.url, "http://expo.dev");
    const sanitizedPathname = url.pathname;
    debug("Request", sanitizedPathname);
    if (routesManifest.rewrites) {
      for (const route of routesManifest.rewrites) {
        if (!route.namedRegex.test(sanitizedPathname)) {
          continue;
        }
        const url2 = getRedirectRewriteLocation(request, route);
        if (url2) {
          request = new Request(
            new URL(url2, new URL(request.url).origin),
            request
          );
        }
      }
    }
    if (routesManifest.redirects) {
      for (const route of routesManifest.redirects) {
        if (!route.namedRegex.test(sanitizedPathname)) {
          continue;
        }
        const Location = getRedirectRewriteLocation(request, route);
        if (Location) {
          debug("Redirecting", Location);
          return new Response(null, {
            status: route.permanent ? 308 : 307,
            headers: {
              Location
            }
          });
        }
      }
    }
    if (request.method === "GET" || request.method === "HEAD") {
      for (const route of routesManifest.htmlRoutes) {
        if (!route.namedRegex.test(sanitizedPathname)) {
          continue;
        }
        updateRequestWithConfig(request, route);
        const contents = await getHtml(request, route);
        if (!contents) {
          return new Response("Not found", {
            status: 404,
            headers: {
              "Content-Type": "text/plain"
            }
          });
        } else if (contents instanceof Response) {
          return contents;
        }
        return new Response(contents, {
          status: 200,
          headers: {
            "Content-Type": "text/html"
          }
        });
      }
    }
    for (const route of routesManifest.apiRoutes) {
      if (!route.namedRegex.test(sanitizedPathname)) {
        continue;
      }
      const func = await getApiRoute(route);
      if (func instanceof Response) {
        return func;
      }
      const routeHandler = func?.[request.method];
      if (!routeHandler) {
        return new Response("Method not allowed", {
          status: 405,
          headers: {
            "Content-Type": "text/plain"
          }
        });
      }
      const params = updateRequestWithConfig(request, route);
      try {
        return await routeHandler(request, params);
      } catch (error) {
        if (error instanceof Error) {
          logApiRouteExecutionError(error);
        }
        return handleApiRouteError(error);
      }
    }
    for (const route of routesManifest.notFoundRoutes) {
      if (!route.namedRegex.test(sanitizedPathname)) {
        continue;
      }
      updateRequestWithConfig(request, route);
      const contents = await getHtml(request, route);
      if (!contents) {
        return new Response("Not found", {
          status: 404,
          headers: {
            "Content-Type": "text/plain"
          }
        });
      } else if (contents instanceof Response) {
        return contents;
      }
      return new Response(contents, {
        status: 404,
        headers: {
          "Content-Type": "text/html"
        }
      });
    }
    const response = new Response("Not found", {
      status: 404,
      headers: {
        "Content-Type": "text/plain"
      }
    });
    return response;
  };
}
function matchDynamicName(name) {
  return name.match(/^\[([^[\](?:\.\.\.)]+?)\]$/)?.[1];
}
function matchDeepDynamicRouteName(name) {
  return name.match(/^\[\.\.\.([^/]+?)\]$/)?.[1];
}
function updateRequestWithConfig(request, config) {
  const params = {};
  const url = new URL(request.url);
  const match = config.namedRegex.exec(url.pathname);
  if (match?.groups) {
    for (const [key, value] of Object.entries(match.groups)) {
      const namedKey = config.routeKeys[key];
      params[namedKey] = value;
    }
  }
  return params;
}
function getRedirectRewriteLocation(request, route) {
  if (route.methods) {
    if (!route.methods.includes(request.method)) {
      return;
    }
  }
  const params = updateRequestWithConfig(request, route);
  const urlSearchParams = new URL(request.url).searchParams;
  let location = route.page.split("/").map((segment) => {
    let match = matchDynamicName(segment);
    if (match) {
      const value = params[match];
      delete params[match];
      return value?.split("/")[0];
    }
    match = matchDeepDynamicRouteName(segment);
    if (match) {
      const value = params[match];
      delete params[match];
      return value;
    }
    return segment;
  }).join("/");
  if (Object.keys(params).length > 0 || urlSearchParams.size > 0) {
    location += "?" + new URLSearchParams({
      ...params,
      ...Object.fromEntries(urlSearchParams.entries())
    }).toString();
  }
  return location;
}

const freestyleExpoServer = ({
  CLIENT_BUILD_DIR = path.join(process.cwd(), "dist/client"),
  SERVER_BUILD_DIR = path.join(process.cwd(), "dist/server")
} = {}) => {
  const expoHandler = createRequestHandler(SERVER_BUILD_DIR);
  const app = new Hono();
  app.use("*", serveStatic({ root: CLIENT_BUILD_DIR }));
  app.all("*", async (c, next) => {
    console.log("Request received:", c.req.url);
    const response = await expoHandler(c.req.raw);
    return response;
  });
  Deno.serve(app.fetch);
};

export { freestyleExpoServer };
