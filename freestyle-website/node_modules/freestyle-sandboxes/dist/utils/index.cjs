'use strict';

var glob = require('glob');
var fs = require('fs/promises');
var require$$0 = require('fs');
var path = require('path');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespaceDefault(fs);
var require$$0__namespace = /*#__PURE__*/_interopNamespaceDefault(require$$0);
var path__namespace = /*#__PURE__*/_interopNamespaceDefault(path);

const prepareDirForDeployment = async (directory) => {
  const files = {};
  const patterns = await glob.glob("**/*", {
    cwd: directory,
    nodir: true,
    ignore: ["**/node_modules/**"],
    absolute: false,
    dot: true,
    posix: true
  });
  for (const relativePath of patterns) {
    try {
      const filePath = path__namespace.join(directory, relativePath);
      const content = await fs__namespace.readFile(filePath, "base64");
      files[relativePath] = {
        content,
        encoding: "base64"
      };
    } catch (error) {
      console.error(`Error reading file ${relativePath}:`, error);
    }
  }
  return {
    kind: "files",
    files
  };
};
const prepareDirForDeploymentSync = (directory) => {
  const files = {};
  const patterns = glob.globSync("**/*", {
    cwd: directory,
    nodir: true,
    ignore: ["**/node_modules/**"],
    absolute: false,
    dot: true,
    posix: true
  });
  for (const relativePath of patterns) {
    try {
      const filePath = path__namespace.join(directory, relativePath);
      const content = require$$0__namespace.readFileSync(filePath, "base64");
      files[relativePath] = {
        content,
        encoding: "base64"
      };
    } catch (error) {
      console.error(`Error reading file ${relativePath}:`, error);
    }
  }
  return {
    kind: "files",
    files
  };
};
const prepareNextJsForDeployment = async (directory) => {
  const publicDir = path__namespace.join(directory, "public");
  const nextPublicDestination = path__namespace.join(directory, ".next/standalone/public");
  const staticDir = path__namespace.join(directory, ".next/static");
  const nextStaticDestination = path__namespace.join(
    directory,
    ".next/standalone/.next/static"
  );
  await fs__namespace.mkdir(nextPublicDestination, { recursive: true });
  await fs__namespace.copyFile(publicDir, nextPublicDestination);
  await fs__namespace.mkdir(nextStaticDestination, { recursive: true });
  await fs__namespace.copyFile(staticDir, nextStaticDestination);
  return await prepareDirForDeployment(directory);
};

exports.prepareDirForDeployment = prepareDirForDeployment;
exports.prepareDirForDeploymentSync = prepareDirForDeploymentSync;
exports.prepareNextJsForDeployment = prepareNextJsForDeployment;
