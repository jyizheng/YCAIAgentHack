import { createClient, createConfig } from '@hey-api/client-fetch';

const client = createClient(createConfig());
const handleDeployCloudstate = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/cloudstate/v1/deploy"
  });
};
const handleBackupCloudstate = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/cloudstate/v1/projects/{id}/backup"
  });
};
const handleVerifyWildcard = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/domains/v1/certs/{domain}/wildcard"
  });
};
const handleListDomains = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/domains/v1/domains"
  });
};
const handleListDomainMappings = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/domains/v1/mappings"
  });
};
const handleInsertDomainMapping = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/domains/v1/mappings/{domain}"
  });
};
const handleDeleteDomainMapping = (options) => {
  return (options?.client ?? client).delete({
    ...options,
    url: "/domains/v1/mappings/{domain}"
  });
};
const handleListDomainVerificationRequests = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/domains/v1/verifications"
  });
};
const handleVerifyDomain = (options) => {
  return (options?.client ?? client).put({
    ...options,
    url: "/domains/v1/verifications"
  });
};
const handleCreateDomainVerification = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/domains/v1/verifications"
  });
};
const handleDeleteDomainVerification = (options) => {
  return (options?.client ?? client).delete({
    ...options,
    url: "/domains/v1/verifications"
  });
};
const handleEphemeralDevServer = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/ephemeral/v1/dev-servers"
  });
};
const handleExecOnEphemeralDevServer = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/ephemeral/v1/dev-servers/exec"
  });
};
const handleWriteFileFromEphemeralDevServer = (options) => {
  return (options?.client ?? client).put({
    ...options,
    url: "/ephemeral/v1/dev-servers/files/{*filepath}"
  });
};
const handleReadFileFromEphemeralDevServer = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/ephemeral/v1/dev-servers/files/{*filepath}"
  });
};
const handleGitCommitPush = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/ephemeral/v1/dev-servers/git/commit-push"
  });
};
const handleShutdownDevServer = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/ephemeral/v1/dev-servers/shutdown"
  });
};
const handleDevServerStatus = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/ephemeral/v1/dev-servers/status"
  });
};
const handleListExecuteRuns = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/execute/v1/deployments"
  });
};
const handleGetExecuteRun = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/execute/v1/deployments/{deployment}"
  });
};
const handleExecuteScript = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/execute/v1/script"
  });
};
const handleCreateIdentity = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/git/v1/identity"
  });
};
const handleDeleteIdentity = (options) => {
  return (options?.client ?? client).delete({
    ...options,
    url: "/git/v1/identity/{identity}"
  });
};
const handleListPermissions = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/git/v1/identity/{identity}/permissions"
  });
};
const handleDescribePermission = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/git/v1/identity/{identity}/permissions/{repo}"
  });
};
const handleGrantPermission = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/git/v1/identity/{identity}/permissions/{repo}"
  });
};
const handleRevokePermission = (options) => {
  return (options?.client ?? client).delete({
    ...options,
    url: "/git/v1/identity/{identity}/permissions/{repo}"
  });
};
const handleUpdatePermission = (options) => {
  return (options?.client ?? client).patch({
    ...options,
    url: "/git/v1/identity/{identity}/permissions/{repo}"
  });
};
const handleListGitTokens = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/git/v1/identity/{identity}/tokens"
  });
};
const handleCreateGitToken = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/git/v1/identity/{identity}/tokens"
  });
};
const handleRevokeGitToken = (options) => {
  return (options?.client ?? client).delete({
    ...options,
    url: "/git/v1/identity/{identity}/tokens"
  });
};
const handleListRepositories = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/git/v1/repo"
  });
};
const handleCreateRepo = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/git/v1/repo"
  });
};
const handleGetDefaultBranch = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/git/v1/repo/{repo_id}/default-branch"
  });
};
const handleSetDefaultBranch = (options) => {
  return (options?.client ?? client).put({
    ...options,
    url: "/git/v1/repo/{repo_id}/default-branch"
  });
};
const getGithubSync = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/git/v1/repo/{repo_id}/github-sync"
  });
};
const configureGithubSync = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/git/v1/repo/{repo_id}/github-sync"
  });
};
const removeGithubSync = (options) => {
  return (options?.client ?? client).delete({
    ...options,
    url: "/git/v1/repo/{repo_id}/github-sync"
  });
};
const handleDeleteRepo = (options) => {
  return (options?.client ?? client).delete({
    ...options,
    url: "/git/v1/repo/{repo}"
  });
};
const handleGetContents = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/git/v1/repo/{repo}/contents/{*path}"
  });
};
const handleListGitTriggers = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/git/v1/repo/{repo}/trigger"
  });
};
const handleCreateGitTrigger = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/git/v1/repo/{repo}/trigger"
  });
};
const handleDeleteGitTrigger = (options) => {
  return (options?.client ?? client).delete({
    ...options,
    url: "/git/v1/repo/{repo}/trigger/{trigger}"
  });
};
const handleGetLogs = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/observability/v1/logs"
  });
};
const handleDeployWebV2 = (options) => {
  return (options?.client ?? client).post({
    ...options,
    url: "/web/v1/deployment"
  });
};
const handleListWebDeploys = (options) => {
  return (options?.client ?? client).get({
    ...options,
    url: "/web/v1/deployments"
  });
};

class FreestyleSandboxes {
  client;
  options;
  constructor(options) {
    this.options = options ?? {};
    if (!options?.apiKey) {
      this.options.apiKey = process.env.FREESTYLE_API_KEY;
    }
    if (typeof Deno !== "undefined") {
      class FreestyleRequest extends Request {
        constructor(input, init) {
          if (init.client !== void 0) {
            console.warn("Unsupported client detected, using default client");
            delete init.client;
          }
          super(input, init);
        }
      }
      Request = FreestyleRequest;
    }
    this.client = createClient({
      baseUrl: this.options?.baseUrl ?? "https://api.freestyle.sh",
      headers: {
        Authorization: `Bearer ${this.options.apiKey}`,
        ...this.options?.headers
      }
    });
  }
  /**
   * Execute a script in a sandbox.
   */
  async executeScript(script, config) {
    const response = await handleExecuteScript({
      client: this.client,
      body: {
        script,
        config
      }
    });
    if (response.data) {
      return response.data;
    }
    throw {
      message: `Failed to execute script: 

${script}

Error:

${JSON.stringify(
        response
      )}`,
      error: response.error
    };
  }
  /**
   * Deploy a Web project to a sandbox.
   */
  async deployWeb(source, config) {
    const response = await handleDeployWebV2({
      client: this.client,
      body: {
        source,
        config
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to deploy web project

Status: ${response.response.status}

Message: ${response.error?.message}`
    );
  }
  /**
   * Deploy a Cloudstate project to a sandbox.
   */
  async deployCloudstate(body) {
    const response = await handleDeployCloudstate({
      client: this.client,
      body
    });
    if (response.data) {
      return response.data;
    }
    throw new Error("Failed to deploy Cloudstate project");
  }
  /**
   * Get a backup of a Cloudstate project in a sandbox.
   * @param id The ID of the Cloudstate project.
   * @returns The backup of the Cloudstate project.
   * @throws An error if the backup could not be retrieved.
   */
  async backupCloudstate(id) {
    const response = await handleBackupCloudstate({
      client: this.client,
      path: {
        id
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error("Failed to get backup of Cloudstate project");
  }
  /**
   * Get logs for an execute run, or web deployment.
   * @param id The ID of the sandbox.
   * @returns The logs for the sandbox.
   * @throws An error if the logs could not be retrieved.
   */
  async getLogs(id) {
    const response = await handleGetLogs({
      client: this.client,
      query: {
        deploymentId: id
      }
      // path: {
      //   id: id,
      // },
    });
    if (response.data) {
      return response.data;
    }
    throw new Error("Failed to get logs for sandbox");
  }
  /**
   * Create a a domain verification request.
   * @param domain The domain to verify.
   * @returns The domain verification token.
   */
  async createDomainVerificationRequest(domain) {
    const response = await handleCreateDomainVerification({
      client: this.client,
      body: {
        domain
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(response.error.message);
  }
  async verifyDomainVerificationRequest(id) {
    const response = await handleVerifyDomain({
      client: this.client,
      body: {
        id
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to verify domain verification request with ID ${id}: ${response.error.message}`
    );
  }
  /**
   * Verify a domain. Note, this requires the domain verification token to be already set up.
   * @param domain The domain to verify.
   * @returns The domain verification request.
   */
  async verifyDomain(domain) {
    const response = await handleVerifyDomain({
      client: this.client,
      body: {
        domain
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to verify domain ${domain}: ${response.error.message}`
    );
  }
  async listDomains() {
    const response = await handleListDomains({
      client: this.client
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(`Failed to list domains
${response.error.message}`);
  }
  async listDomainVerificationRequests() {
    const response = await handleListDomainVerificationRequests(
      {
        client: this.client
      }
    );
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to list domain verification requests
${response.error.message}`
    );
  }
  async deleteDomainVerificationRequest(domain, verificationCode) {
    const response = await handleDeleteDomainVerification({
      client: this.client,
      body: {
        domain,
        verificationCode
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to delete domain verification request for domain ${domain}: ${response.error.message}`
    );
  }
  async listWebDeployments(limit, offset) {
    const response = await handleListWebDeploys({
      client: this.client,
      query: {
        limit: limit ?? 10,
        offset: offset ?? 0
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to list web deployments
${response.error.message}`
    );
  }
  async listExecuteRuns(limit, offset) {
    const response = await handleListExecuteRuns({
      client: this.client,
      query: {
        limit: limit ?? 10,
        offset: offset ?? 0
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(`Failed to list execute runs
${response.error.message}`);
  }
  async getExecuteRun(id) {
    const response = await handleGetExecuteRun({
      client: this.client,
      path: {
        deployment: id
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to get execute run with ID ${id}: ${response.error.message}`
    );
  }
  /** Provision a wildcard certificate for domain. */
  async provisionWildcard(domain) {
    const response = await handleVerifyWildcard({
      client: this.client,
      path: {
        domain
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to provision wildcard for domain ${domain}: ${response.error.message}`
    );
  }
  /**
   * Insert a domain mapping for a deployment.
   */
  async insertDomainMapping({
    domain,
    deploymentId
  }) {
    const response = await handleInsertDomainMapping({
      client: this.client,
      path: {
        domain
      },
      body: {
        deploymentId
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to insert domain mapping for domain ${domain} and deployment ${deploymentId}: ${response.error.message}`
    );
  }
  /**
   * Remove a domain mapping for a deployment.
   */
  async removeDomainMapping({
    domain
  }) {
    const response = await handleDeleteDomainMapping({
      client: this.client,
      path: {
        domain
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to remove domain mapping for domain ${domain}: ${response.error.message}`
    );
  }
  async listDomainMappings({
    domain,
    domainOwnership,
    limit = 10,
    offset = 0
  }) {
    const response = await handleListDomainMappings({
      client: this.client,
      query: {
        limit,
        offset,
        domain,
        domainOwnership
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to list domain mappings: ${JSON.stringify(response.error)}`
    );
  }
  /**
   * Create a new git repository.
   */
  async createGitRepository({
    name,
    public: pub = false,
    source,
    import: _import,
    defaultBranch
  }) {
    const response = await handleCreateRepo({
      client: this.client,
      body: {
        name,
        public: pub,
        source,
        import: _import,
        defaultBranch
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to create git repository ${name}: ${response.error}`
    );
  }
  /**
   * List git repositories.
   */
  async listGitRepositories({
    limit = 10,
    offset = 0
  } = {}) {
    const response = await handleListRepositories({
      client: this.client,
      query: {
        limit,
        offset
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(`Failed to list git repositories: ${response.error}`);
  }
  /**
   * Delete a git repository.
   */
  async deleteGitRepository({
    repoId
  }) {
    const response = await handleDeleteRepo({
      client: this.client,
      path: {
        repo: repoId
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to delete git repository ${repoId}: ${response.error}`
    );
  }
  /**
   * Create a new git identity.
   */
  async createGitIdentity() {
    const response = await handleCreateIdentity({
      client: this.client
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(`Failed to create git identity: ${response.error}`);
  }
  /**
   * Delete a git identity.
   */
  async deleteGitIdentity({
    identityId
  }) {
    const response = await handleDeleteIdentity({
      client: this.client,
      path: {
        identity: identityId
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(`Failed to delete git identity: ${response.error}`);
  }
  /**
   * Grant a git identity access to a repository.
   */
  async grantGitPermission({
    repoId,
    identityId,
    permission
  }) {
    const response = await handleGrantPermission({
      client: this.client,
      path: {
        repo: repoId,
        identity: identityId
      },
      body: {
        permission
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to grant access to git identity ${identityId} for repository ${repoId}: ${response.error}`
    );
  }
  /**
   * Update a git identity's permissions on a repository.
   */
  async updateGitPermission({
    repoId,
    identityId,
    permission
  }) {
    const response = await handleUpdatePermission({
      client: this.client,
      path: {
        repo: repoId,
        identity: identityId
      },
      body: {
        permission
      }
    });
    if (response.data) {
      return;
    }
    throw new Error(
      `Failed to update permission for git identity ${identityId} for repository ${repoId}: ${response.error}`
    );
  }
  /**
   * Revoke a git identity's access to a repository.
   */
  async revokeGitPermission({
    repoId,
    identityId
  }) {
    const response = await handleRevokePermission({
      client: this.client,
      path: {
        repo: repoId,
        identity: identityId
      }
    });
    if (response.data) {
      return;
    }
    throw new Error(
      `Failed to revoke access to git identity ${identityId} for repository ${repoId}: ${response.error}`
    );
  }
  /**
   * List access permissions for a git identity.
   */
  async listGitPermissions({
    identityId
  }) {
    const response = await handleListPermissions({
      client: this.client,
      path: {
        identity: identityId
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to list permissions for git identity ${identityId}: ${response.error}`
    );
  }
  /**
   * Get the permission of a git identity on a repository.
   */
  async getGitPermission({
    repoId,
    identityId
  }) {
    const response = await handleDescribePermission({
      client: this.client,
      path: {
        repo: repoId,
        identity: identityId
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to get permission for git identity ${identityId} on repository ${repoId}: ${response.error}`
    );
  }
  /**
   * Create a new git access token for an identity.
   */
  async createGitAccessToken({
    identityId
  }) {
    const response = await handleCreateGitToken({
      client: this.client,
      path: {
        identity: identityId
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to create git access token: ${response.error.message}`
    );
  }
  /**
   * Revoke a git access token.
   */
  async revokeGitAccessToken({
    identityId,
    tokenId
  }) {
    const response = await handleRevokeGitToken({
      client: this.client,
      body: {
        tokenId
      },
      path: {
        identity: identityId
      }
    });
    if (response.data) {
      return;
    }
    throw new Error(
      `Failed to revoke git access token ${tokenId}: ${response.error.message}`
    );
  }
  /**
   * List git access tokens for an identity.
   */
  async listGitAccessTokens({
    identityId
  }) {
    const response = await handleListGitTokens({
      client: this.client,
      path: {
        identity: identityId
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to list git access tokens: ${response.error.message}`
    );
  }
  /**
   * List git triggers for a repository.
   */
  async listGitTriggers({
    repoId
  }) {
    const response = await handleListGitTriggers({
      client: this.client,
      path: {
        repo: repoId
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to list git triggers for repository ${repoId}: ${response.error.message}`
    );
  }
  /**
   * Create a git trigger for a repository.
   */
  async createGitTrigger({
    repoId,
    trigger,
    action
  }) {
    const response = await handleCreateGitTrigger({
      client: this.client,
      path: {
        repo: repoId
      },
      body: {
        trigger,
        action
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to create git trigger for repository ${repoId}: ${response.error.message}`
    );
  }
  /**
   * Delete a git trigger.
   */
  async deleteGitTrigger({ triggerId }) {
    const response = await handleDeleteGitTrigger({
      client: this.client,
      path: {
        trigger: triggerId
      }
    });
    if (response.data) {
      return;
    }
    throw new Error(
      `Failed to delete git trigger ${triggerId}: ${response.error.message}`
    );
  }
  /**
   * Set the default branch for a git repository.
   */
  async setGitRepoDefaultBranch({
    repoId,
    defaultBranch
  }) {
    const response = await handleSetDefaultBranch({
      client: this.client,
      path: {
        repo_id: repoId
      },
      body: {
        defaultBranch
      }
    });
    if (response.error) {
      throw new Error(`Failed to set default branch: ${response.error}`);
    }
  }
  /**
   * Get the default branch for a git repository.
   */
  async getGitRepoDefaultBranch({
    repoId
  }) {
    const response = await handleGetDefaultBranch({
      client: this.client,
      path: { repo_id: repoId }
    });
    if (response.data) {
      return response.data.defaultBranch;
    }
    throw new Error(
      `Failed to get default branch for repository ${repoId}: ${response.error}`
    );
  }
  /**
   * Get the contents of a git repository at the given path.
   */
  async getGitRepoContents({
    repoId,
    path,
    ref
  }) {
    const response = await handleGetContents({
      client: this.client,
      path: {
        repo: repoId,
        "*path": path ?? null
      },
      query: {
        ref
      }
    });
    if (response.data) {
      return response.data;
    }
    throw new Error(
      `Failed to get git repository contents: ${response.error.message}`
    );
  }
  /**
   * Configure a git repository to sync with GitHub.
   */
  async configureGitRepoGitHubSync({
    repoId,
    githubRepoName
  }) {
    const response = await configureGithubSync({
      client: this.client,
      path: {
        repo_id: repoId
      },
      body: {
        githubRepoName
      }
    });
    if (response.error) {
      throw new Error(`Failed to configure GitHub sync: ${response.error}`);
    }
  }
  /**
   * Remove the GitHub sync configuration for a git repository.
   */
  async removeGitRepoGitHubSync({ repoId }) {
    const response = await removeGithubSync({
      client: this.client,
      path: {
        repo_id: repoId
      }
    });
    if (response.error) {
      throw new Error(`Failed to remove GitHub sync: ${response.error}`);
    }
  }
  /**
   * Get the GitHub sync configuration for a git repository.
   */
  async getGitRepoGitHubSyncConfig({
    repoId
  }) {
    const response = await getGithubSync({
      client: this.client,
      path: {
        repo_id: repoId
      }
    });
    if (response.response.status === 404) {
      return null;
    }
    if (response.error) {
      throw new Error(`Failed to get GitHub sync config: ${response.error}`);
    }
    return response.data ?? null;
  }
  /**
   * Request a dev server for a repository. If a dev server is already running
   * for that repository, it will return a url to that server. Dev servers are
   * ephemeral so you should call this function every time you need a url. Do
   * not store the url in your database!
   */
  async requestDevServer(options) {
    function formatHook(serverUrl, repoUrl) {
      const hook = serverUrl + "/__freestyle_dev_server/update/git?repo=" + encodeURIComponent(repoUrl);
      return hook;
    }
    const response = await handleEphemeralDevServer({
      client: this.client,
      body: {
        ...options,
        // @ts-ignore
        repo: options.repoUrl
      }
    });
    if (response.error) {
      throw new Error(
        // @ts-ignore
        `Failed to request dev server: ${response.error.message}`
      );
    }
    if (response.data.isNew) {
      const rId = options.repoId || options.repoUrl?.split("/").at(-1);
      await this.createGitTrigger({
        repoId: rId,
        action: {
          endpoint: formatHook(
            response.data?.url,
            options.repoUrl || `https://git.freestyle.sh/${rId}`
          ),
          action: "webhook"
        },
        trigger: {
          event: "push"
        }
      });
    }
    if (!response.data) {
      throw new Error(`Failed to request dev server: ${response.error}`);
    }
    const data = response.data;
    const devServerInstance = {
      repoId: options.repoId || options.repo || "",
      kind: "repo"
    };
    const client = this.client;
    const that = this;
    return {
      ...response.data,
      isNew: data.isNew,
      ephemeralUrl: data.ephemeralUrl ?? data.url,
      mcpEphemeralUrl: data.mcpEphemeralUrl ?? data.url + "/mcp",
      codeServerUrl: data.codeServerUrl ?? (data.ephemeralUrl ?? data.url) + "/__freestyle_code_server/?folder=/template",
      async status() {
        const response2 = await handleDevServerStatus({
          client,
          body: {
            devServer: devServerInstance
          }
        });
        if (response2.error) {
          throw new Error(`Failed to get status: ${response2.error}`);
        }
        return {
          installing: response2.data.installing,
          devRunning: response2.data.devRunning
        };
      },
      async commitAndPush(message) {
        const response2 = await handleGitCommitPush({
          client,
          body: {
            devServer: devServerInstance,
            message
          }
        });
        if (response2.error) {
          throw new Error(`Failed to commit and push: ${response2.error}`);
        }
      },
      async shutdown() {
        const response2 = await handleShutdownDevServer({
          client,
          body: {
            devServer: devServerInstance
          }
        });
        if (response2.error) {
          throw new Error(`Failed to shutdown dev server: ${response2.error}`);
        }
        return {
          success: response2.data.success,
          message: response2.data.message
        };
      },
      fs: {
        async ls(path = "") {
          const response2 = await handleReadFileFromEphemeralDevServer({
            client,
            path: {
              "*filepath": path
            },
            body: {
              devServer: devServerInstance,
              encoding: "utf-8"
            }
          });
          if (response2.error) {
            throw new Error(`Failed to list directory: ${response2.error}`);
          }
          if (!response2.data?.content) {
            return [];
          }
          if (response2.data.content.kind === "directory") {
            return response2.data.content.files;
          }
          return [];
        },
        async *watch() {
          const response2 = await that.fetch(
            "/ephemeral/v1/dev-servers/watch-files",
            {
              method: "POST",
              body: JSON.stringify({
                devServer: {
                  repoId: devServerInstance.repoId,
                  kind: devServerInstance.kind
                }
              })
            }
          );
          if (!response2.ok) {
            throw new Error(
              `Failed to fetch stream: ${response2.status} ${response2.statusText}`
            );
          }
          if (!response2.body) {
            throw new Error("Failed to fetch stream: No response body");
          }
          const reader = response2.body.getReader();
          const decoder = new TextDecoder("utf-8");
          let buffer = "";
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            let newlineIndex;
            while ((newlineIndex = buffer.indexOf("\n")) >= 0) {
              const line = buffer.slice(0, newlineIndex).trim();
              buffer = buffer.slice(newlineIndex + 1);
              if (line) {
                yield JSON.parse(line);
              }
            }
          }
          if (buffer.trim()) {
            yield JSON.parse(buffer.trim());
          }
        },
        async readFile(path, encoding = "utf-8") {
          const response2 = await handleReadFileFromEphemeralDevServer({
            client,
            path: {
              "*filepath": path
            },
            body: {
              devServer: devServerInstance,
              encoding
            }
          });
          if (response2.error) {
            throw new Error(`Failed to read file: ${response2.error}`);
          }
          if (!response2.data?.content || response2.data.content.kind !== "file") {
            throw new Error(`Not a file or file not found: ${path}`);
          }
          return response2.data.content.content;
        },
        async writeFile(path, content, encoding = "utf-8") {
          const contentStr = typeof content === "string" ? content : Buffer.from(content).toString(encoding);
          const response2 = await handleWriteFileFromEphemeralDevServer({
            client,
            path: {
              "*filepath": path
            },
            body: {
              devServer: devServerInstance,
              content: contentStr,
              encoding
            }
          });
          if (response2.error) {
            throw new Error(
              `Failed to write file: ${JSON.stringify(response2.error)}`
            );
          }
        }
      },
      process: {
        async exec(cmd, background = false) {
          const response2 = await handleExecOnEphemeralDevServer(
            {
              client,
              body: {
                devServer: devServerInstance,
                command: cmd,
                background
              }
            }
          );
          if (response2.error) {
            throw new Error(`Failed to execute command: ${response2.error}`);
          }
          return {
            id: response2.data.id,
            isNew: response2.data.isNew,
            stdout: response2.data.stdout,
            stderr: response2.data.stderr
          };
        }
      }
    };
  }
  fetch(path, init) {
    const headers = new Headers(init?.headers);
    for (const [key, value] of Object.entries(this.options.headers ?? {})) {
      if (!headers.has(key)) {
        headers.append(key, value);
      }
    }
    if (!headers.has("Authorization")) {
      headers.append("Authorization", `Bearer ${this.options.apiKey}`);
    }
    if (!headers.has("Content-Type")) {
      headers.append("Content-Type", "application/json");
    }
    const url = new URL(
      path,
      this.options.baseUrl ?? "https://api.freestyle.sh"
    );
    return fetch(url, {
      ...init ?? {},
      headers
    });
  }
}

export { FreestyleSandboxes };
