// This file is auto-generated by @hey-api/openapi-ts

/**
 * Identical to [`RepositoryInfo`], but with the permissions field added.
 */
export type AccessibleRepository = {
    id: string;
    name?: (string) | null;
    accountId: string;
    permissions: AccessLevel;
    visibility: Visibility;
};

export type AccessLevel = 'read' | 'write';

export type AccessTokenInfo = {
    id: string;
};

export type Behavior = 'regex' | 'exact';

/**
 * The encoding of a blob from the API. Always `base64`.
 */
export type BlobEncoding = 'base64';

/**
 * Blob object
 */
export type BlobObject = {
    /**
     * The content of the blob, base64 encoded.
     */
    content: string;
    /**
     * The encoding of the blob. Always `base64`.
     */
    encoding: BlobEncoding;
    /**
     * The object's hash.
     */
    sha: string;
};

export type BranchDetails = {
    default: boolean;
    name: string;
    target?: (string) | null;
};

export type CommitList = {
    /**
     * List of commits
     */
    commits: Array<CommitObject>;
    /**
     * Number of commits returned in this page
     */
    count: number;
    /**
     * Number of commits skipped (offset)
     */
    offset: number;
    /**
     * Maximum number of commits requested (limit)
     */
    limit: number;
    /**
     * Total number of commits available in the branch
     */
    total: number;
};

/**
 * Commit object
 */
export type CommitObject = {
    /**
     * The author of the commit
     */
    author: Signature;
    /**
     * The committer
     */
    committer: Signature;
    /**
     * The commit message
     */
    message: string;
    /**
     * The ID of the tree pointed to by this commit
     */
    tree: CommitTree;
    /**
     * Parent commit(s) of this commit
     */
    parents: Array<CommitParent>;
    /**
     * The commit's hash ID
     */
    sha: string;
};

export type CommitParent = {
    /**
     * The commit's hash ID
     */
    sha: string;
};

export type CommitTree = {
    /**
     * The tree's hash ID
     */
    sha: string;
};

export type ConfigureGithubSyncRequest = {
    /**
     * The GitHub repository name in "owner/repo" format
     */
    githubRepoName: string;
};

export type CreateDomainMappingRequest = {
    deploymentId: string;
};

export type CreatedToken = {
    id: string;
    token: string;
};

export type CreateRecordParams = {
    domain: string;
    record: DnsRecordData;
};

export type CreateRepoImport = {
    /**
     * A map of file names to their contents.
     */
    files: {
        [key: string]: (string);
    };
    commitMessage: string;
    authorName?: (string) | null;
    authorEmail?: (string) | null;
    type: 'files';
} | {
    url: string;
    dir?: (string) | null;
    commitMessage: string;
    authorName?: (string) | null;
    authorEmail?: (string) | null;
    type: 'tar';
} | {
    url: string;
    dir?: (string) | null;
    commitMessage: string;
    authorName?: (string) | null;
    authorEmail?: (string) | null;
    type: 'zip';
} | {
    url: string;
    branch?: (string) | null;
    dir?: (string) | null;
    commitMessage: string;
    authorName?: (string) | null;
    authorEmail?: (string) | null;
    type: 'git';
};

export type type = 'files';

export type CreateRepoRequest = {
    source?: (null | CreateRepoSource);
    import?: (null | CreateRepoImport);
    defaultBranch?: (string) | null;
};

export type CreateRepositoryRequest = {
    /**
     * This name is not visible to users, and is only accessible to you via API and in the
     * dashboard. Mostly useful for observability.
     */
    name?: (string) | null;
    public?: boolean;
    /**
     * The default branch name for the repository. Defaults to "main" if not specified.
     */
    defaultBranch?: (string) | null;
    /**
     * Fork from another Git repository. Cannot be used with `import`.
     */
    source?: CreateRepoSource;
    /**
     * Import static content with an initial commit. Cannot be used with `source`.
     */
    import?: CreateRepoImport;
};

export type CreateRepositoryResponseSuccess = {
    repoId: string;
};

export type CreateRepoSource = {
    url: string;
    branch?: (string) | null;
    depth?: (number) | null;
};

export type CustomBuildOptions = {
    command?: (string) | null;
    envVars?: {
        [key: string]: (string);
    } | null;
    outDir?: (string) | null;
};

export type DeploymentBuildOptions = (CustomBuildOptions) | boolean;

export type DeploymentLogEntry = {
    deploymentId: string;
    accountId: string;
    provisionedAt: string;
    timeout: string;
    state: DeploymentState;
    deployedAt?: (string) | null;
    domains: Array<(string)>;
    envVars: {
        [key: string]: (string);
    };
};

export type DeploymentSource = {
    files: {
        [key: string]: FreestyleFile;
    };
    kind: 'files';
} | {
    url: string;
    kind: 'tar';
} | {
    url: string;
    branch?: (string) | null;
    dir?: (string) | null;
    kind: 'git';
};

export type kind = 'files';

export type DeploymentState = 'provisioning' | 'deployed' | 'failed';

export type DescribePermissionResponseSuccess = {
    identity: string;
    repo: string;
    accessLevel?: (null | AccessLevel);
};

export type DevServer = {
    repoId: string;
    gitRef?: (string) | null;
    kind: 'repo';
};

export type kind2 = 'repo';

export type DevServerRequest = {
    devCommand?: (string) | null;
    preDevCommandOnce?: (string) | null;
    /**
     * @deprecated
     */
    baseId?: (string) | null;
    envVars?: {
        [key: string]: (string);
    } | null;
    repoId?: (string) | null;
    computeClass?: (string) | null;
    /**
     * Timeout in seconds
     */
    timeout?: (number) | null;
    /**
     * @deprecated
     */
    domain?: (string) | null;
    /**
     * @deprecated
     */
    repo?: (string) | null;
    gitRef?: (string) | null;
};

export type DevServerStatusRequest = {
    devServer: DevServer;
};

export type DevServerWatchFilesRequest = {
    devServer: DevServer;
};

export type DnsRecord = {
    kind: DnsRecordKind;
    name: string;
    value: string;
    ttl: string;
    priority?: (number) | null;
    managed: boolean;
};

export type DnsRecordData = {
    kind: DnsRecordKind;
    name: string;
    value: string;
    ttl?: (string) | null;
    priority?: (number) | null;
};

export type DnsRecordKind = 'A' | 'AAAA' | 'CNAME' | 'TXT' | 'NS';

export type DomainVerificationRequest = {
    id: string;
    domain: string;
    accountId: string;
    verificationCode: string;
    createdAt: string;
};

export type ExecRequest = {
    devServer: DevServer;
    command: string;
    /**
     * Spawn this command as a background process and return immediately
     */
    background: boolean;
};

export type ExecuteLogEntry = {
    deployment: string;
    accountId: string;
    provisionedAt: string;
    startedAt?: (string) | null;
    duration?: (string) | null;
    state: ExecuteRunState;
    envVars: {
        [key: string]: (string);
    };
};

export type ExecuteRunInfo = {
    code: string;
    nodeModules: {
        [key: string]: (string);
    };
};

export type ExecuteRunState = 'starting' | 'running' | 'complete';

export type FileReadContent = {
    content: string;
    encoding: string;
    kind: 'file';
} | {
    files: Array<(string)>;
    kind: 'directory';
};

export type kind3 = 'file';

export type FreestyleCloudstateDeployConfiguration = {
    /**
     * ID of the project to deploy, if not provided will create a new project
     */
    domains?: Array<(string)> | null;
    /**
     * The environment variables that the cloudstate deploy can access
     */
    envVars?: {
        [key: string]: (string);
    };
    cloudstateDatabaseId?: (string) | null;
};

export type FreestyleCloudstateDeployErrorResponse = {
    message: string;
};

export type FreestyleCloudstateDeployRequest = {
    classes: string;
    config?: FreestyleCloudstateDeployConfiguration;
};

export type FreestyleCloudstateDeploySuccessResponse = {
    deploymentId: string;
    cloudstateDatabaseId: string;
};

export type FreestyleDeleteDomainVerificationRequest = {
    /**
     * The domain to create a verification code for
     */
    domain: string;
    /**
     * The verification code
     */
    verificationCode: string;
};

export type FreestyleDeployWebConfiguration = {
    /**
     * The entrypoint file for the website, if none is provided, we will try to automatically detect it.
     */
    entrypoint?: (string) | null;
    /**
     * The custom domains for the website, eg. [\"subdomain.yourwebsite.com\"]. You may include a single *.style.dev domain here.
     */
    domains?: Array<(string)> | null;
    /**
     * Project ID was our original way of tracking deployments together, it is now deprecated and will be removed in the future. Please use the domains field to specify the domains for your project.
     * @deprecated
     */
    projectId?: (string) | null;
    /**
     * Node Modules to install for the website, a map of package names to versions, e.g. { \"express\": \"4.17.1\" }. If this and a package-lock.json are provided, the package-lock.json, bun.lockb, pnpm-lock.yaml, or yarn.lock is also provided, the versions here will override the versions in those lock files.
     */
    nodeModules?: {
        [key: string]: (string);
    } | null;
    /**
     * The environment variables that the website can access
     * e.g. { \"RESEND_API_KEY\": \"re_123456789\" }
     */
    envVars?: {
        [key: string]: (string);
    } | null;
    serverStartCheck?: boolean;
    networkPermissions?: Array<FreestyleNetworkPermission> | null;
    build?: (null | DeploymentBuildOptions);
    /**
     * Timeout for the deployment in seconds. If not provided, the default is 10 seconds.
     */
    timeout?: (number) | null;
};

export type FreestyleDeployWebErrorResponse = {
    message: string;
};

export type FreestyleDeployWebPayload = {
    /**
     * The files to deploy, a map of file paths to file contents, e.g. { \"index.js\": {\"content\": \"your main\", \"encoding\": \"utf-8\"}, \"file2.js\": {\"content\": \"your helper\" } }
     *
     * **Do not include node modules in this bundle, they will not work**. Instead, includes a package-lock.json, bun.lockb, pnpm-lock.yaml, or yarn.lock, the node modules for the project will be installed from that lock file, or use the node_modules field in the configuration to specify the node modules to install.
     */
    files: {
        [key: string]: FreestyleFile;
    };
    config?: FreestyleDeployWebConfiguration;
};

export type FreestyleDeployWebPayloadV2 = {
    /**
     * The files to deploy, a map of file paths to file contents, e.g. { \"index.js\": {\"content\": \"your main\", \"encoding\": \"utf-8\"}, \"file2.js\": {\"content\": \"your helper\" } }
     *
     * **Do not include node modules in this bundle, they will not work**. Instead, includes a package-lock.json, bun.lockb, pnpm-lock.yaml, or yarn.lock, the node modules for the project will be installed from that lock file, or use the node_modules field in the configuration to specify the node modules to install.
     */
    source: DeploymentSource;
    config?: FreestyleDeployWebConfiguration;
};

export type FreestyleDeployWebSuccessResponseV2 = {
    deploymentId: string;
    /**
     * @deprecated
     */
    projectId: string;
    domains?: Array<(string)> | null;
    /**
     * The entrypoint file for the website. If not specified we try to automatically detect it.
     */
    entrypoint: string;
};

export type FreestyleDomainVerificationRequest = {
    /**
     * The domain to create a verification code for
     */
    domain: string;
};

export type FreestyleExecuteScriptParams = {
    /**
     * The JavaScript or TypeScript script to execute
     */
    script: string;
    config?: FreestyleExecuteScriptParamsConfiguration;
};

export type FreestyleExecuteScriptParamsConfiguration = {
    /**
     * The environment variables to set for the script
     */
    envVars?: {
        [key: string]: (string);
    };
    /**
     * The node modules to install for the script
     */
    nodeModules?: {
        [key: string]: (string);
    };
    /**
     * Tags for you to organize your scripts, useful for tracking what you're running
     */
    tags?: Array<(string)>;
    /**
     * The script timeout
     */
    timeout?: (number) | null;
    /**
     * If false, we'll not resolve peer dependencies for the packages given, this can speed up execute performance, but will break packages with peers unless the peers are manually specified.
     */
    peerDependencyResolution?: boolean;
    networkPermissions?: Array<FreestyleNetworkPermission> | null;
    /**
     * These headers will be added to every fetch request made through the script
     */
    customHeaders?: {
        [key: string]: (string);
    };
    /**
     * Proxy all outgoing requests through this URL
     */
    proxy?: (string) | null;
};

export type FreestyleExecuteScriptResultSuccess = {
    /**
     * The return value of the default export of the script
     */
    result: unknown;
    logs: Array<FreestyleJavaScriptLog>;
};

export type FreestyleFile = {
    /**
     * The content of the file
     */
    content: string;
    /**
     * The encoding of the file. Either **utf-8** or **base64**
     */
    encoding?: string;
};

export type FreestyleGetLogsResponse = {
    logs: Array<FreestyleLogResponseObject>;
};

export type FreestyleJavaScriptLog = {
    /**
     * The log message
     */
    message: string;
    /**
     * The log level
     */
    type: string;
};

export type FreestyleLogResponseObject = {
    message: string;
    timestamp: string;
};

export type FreestyleNetworkPermission = (NetworkPermissionData & {
    action: 'allow';
}) | (NetworkPermissionData & {
    action: 'deny';
});

export type action = 'allow';

export type FreestyleSandboxDomainMapping = {
    id: string;
    domain: string;
    deploymentId: string;
    ownershipId: string;
    createdAt: string;
};

/**
 * Verify a domain verification request, can either be done for a domain, or for a specific request
 */
export type FreestyleVerifyDomainRequest = {
    domain: string;
} | {
    id: string;
};

export type GetDefaultBranchResponse = {
    defaultBranch: string;
};

export type GitCommitPushRequest = {
    devServer: DevServer;
    message: string;
};

export type GitContents = {
    name: string;
    path: string;
    /**
     * The hash / object ID of the file.
     */
    sha: string;
    size: number;
    /**
     * Base64-encoded content.
     */
    content: string;
    type: 'file';
} | {
    name: string;
    path: string;
    /**
     * The hash / object ID of the directory.
     */
    sha: string;
    entries: Array<GitContentsDirEntryItem>;
    type: 'dir';
};

export type type2 = 'file';

export type GitContentsDirEntryItem = {
    name: string;
    path: string;
    /**
     * The hash / object ID of the file.
     */
    sha: string;
    size: number;
    type: 'file';
} | {
    name: string;
    path: string;
    /**
     * The hash / object ID of the directory.
     */
    sha: string;
    entries: Array<({
    [key: string]: unknown;
})>;
    type: 'dir';
};

export type GithubRepoSyncConfig = {
    freestyleRepoId: string;
    accountId: string;
    installationId: number;
    githubRepoId: number;
    githubRepoName: string;
    createdAt: string;
};

export type GithubSyncConfigResponse = {
    githubRepoName: string;
};

export type GitIdentity = {
    id: string;
    managed: boolean;
};

/**
 * A reference to a Git object
 */
export type GitReference = {
    /**
     * The name of the ref (e.g., "refs/heads/main" or "refs/tags/v1.0.0")
     */
    name: string;
    /**
     * The SHA-1 hash of the Git object this reference points to
     */
    sha: string;
};

export type GitRepositoryTrigger = {
    repositoryId: string;
    trigger: ({
    branches?: Array<(string)> | null;
    globs?: Array<(string)> | null;
    event: 'push';
});
    action: ({
    endpoint: string;
    action: 'webhook';
});
    managed: boolean;
    id: string;
    createdAt: string;
};

export type event = 'push';

export type action2 = 'webhook';

export type GitTrigger = {
    branches?: Array<(string)> | null;
    globs?: Array<(string)> | null;
    event: 'push';
};

export type GitTriggerAction = {
    endpoint: string;
    action: 'webhook';
};

export type GrantPermissionRequest = {
    permission: AccessLevel;
};

export type InternalServerError = string;

export type ListGitTokensResponseSuccess = {
    tokens: Array<AccessTokenInfo>;
};

export type ListPermissionResponseSuccess = {
    repositories: Array<AccessibleRepository>;
};

export type ListRecordsResponse = {
    records: Array<DnsRecord>;
};

export type NetworkPermissionData = {
    query: string;
    behavior?: Behavior;
};

export type ReadFileEphemeralDevServerResponses = {
    id: string;
    isNew: boolean;
    content: ({
    content: string;
    encoding: string;
    kind: 'file';
} | {
    files: Array<(string)>;
    kind: 'directory';
});
} | {
    id: string;
    isNew: boolean;
} | InternalServerError;

export type RepositoryInfo = {
    id: string;
    name?: (string) | null;
    accountId: string;
    visibility: Visibility;
    defaultBranch: string;
};

export type RepositoryMetadata = {
    branches: {
        [key: string]: BranchDetails;
    };
    tags: {
        [key: string]: TagDetails;
    };
    defaultBranch: string;
};

export type RevokeGitTokenRequest = {
    tokenId: string;
};

export type SetDefaultBranchRequest = {
    defaultBranch: string;
};

export type SetDefaultBranchResponse = {
    [key: string]: unknown;
};

export type ShutdownDevServerRequest = {
    /**
     * The dev server to shutdown
     */
    devServer: DevServer;
};

export type Signature = {
    /**
     * The date marker for this signature
     */
    date: string;
    name: string;
    email: string;
};

export type TagDetails = {
    name: string;
    target: string;
    message?: (string) | null;
};

/**
 * Tag object
 */
export type TagObject = {
    /**
     * The tag name
     */
    name: string;
    tagger?: (null | Signature);
    /**
     * The tag message
     */
    message?: (string) | null;
    /**
     * The object this tag points to
     */
    target: TagTarget;
    /**
     * The tag's hash ID
     */
    sha: string;
};

export type TagTarget = {
    /**
     * The target object's hash ID
     */
    sha: string;
};

export type TreeEntry = {
    path: string;
    sha: string;
    type: 'blob';
} | {
    path: string;
    sha: string;
    type: 'tree';
};

export type type3 = 'blob';

/**
 * Tree object
 */
export type TreeObject = {
    /**
     * The tree's entries
     */
    tree: Array<TreeEntry>;
    /**
     * The tree's hash ID
     */
    sha: string;
};

export type UpdatePermissionRequest = {
    permission: AccessLevel;
};

export type Visibility = 'public' | 'private';

export type HandleDeployCloudstateData = {
    body: FreestyleCloudstateDeployRequest;
};

export type HandleDeployCloudstateResponse = (FreestyleCloudstateDeploySuccessResponse);

export type HandleDeployCloudstateError = (FreestyleCloudstateDeployErrorResponse);

export type HandleBackupCloudstateData = {
    path: {
        id: string;
    };
};

export type HandleBackupCloudstateResponse = (Array<(number)>);

export type HandleBackupCloudstateError = (unknown);

export type HandleListRecordsData = {
    query: {
        domain: string;
    };
};

export type HandleListRecordsResponse = (ListRecordsResponse);

export type HandleListRecordsError = ({
    message: string;
});

export type HandleCreateRecordData = {
    body: CreateRecordParams;
};

export type HandleCreateRecordResponse = ({
    record: DnsRecord;
});

export type HandleCreateRecordError = ({
    message: string;
});

export type HandleDeleteRecordData = {
    query: {
        domain: string;
        record: DnsRecord;
    };
};

export type HandleDeleteRecordResponse = ({
    message: string;
});

export type HandleDeleteRecordError = ({
    message: string;
});

export type HandleVerifyWildcardData = {
    path: {
        domain: string;
    };
};

export type HandleVerifyWildcardResponse = ({
    domain: string;
});

export type HandleVerifyWildcardError = ({
    message: string;
});

export type HandleListDomainsData = {
    query?: {
        implicitlyOwned?: (boolean) | null;
        limit?: (number) | null;
        offset?: (number) | null;
    };
};

export type HandleListDomainsResponse = (Array<{
    domain: string;
    accountId: string;
    createdAt: string;
    id: string;
    verifiedDns: boolean;
    implicitlyOwned: boolean;
    deployToDomain: boolean;
    manageDns: boolean;
    deployToSubdomains: boolean;
}>);

export type HandleListDomainsError = ({
    message: string;
});

export type HandleListDomainMappingsData = {
    query?: {
        domain?: (string) | null;
        domainOwnership?: (string) | null;
        limit?: (number) | null;
        offset?: (number) | null;
    };
};

export type HandleListDomainMappingsResponse = (Array<FreestyleSandboxDomainMapping>);

export type HandleListDomainMappingsError = (unknown);

export type HandleInsertDomainMappingData = {
    body: CreateDomainMappingRequest;
    path: {
        domain: string;
    };
};

export type HandleInsertDomainMappingResponse = (FreestyleSandboxDomainMapping);

export type HandleInsertDomainMappingError = ({
    message: string;
});

export type HandleDeleteDomainMappingData = {
    path: {
        domain: string;
    };
};

export type HandleDeleteDomainMappingResponse = (unknown);

export type HandleDeleteDomainMappingError = ({
    message: string;
});

export type HandleListDomainVerificationRequestsResponse = (Array<{
    verificationCode: string;
    domain: string;
    createdAt: string;
}>);

export type HandleListDomainVerificationRequestsError = ({
    message: string;
});

export type HandleVerifyDomainData = {
    body: FreestyleVerifyDomainRequest;
};

export type HandleVerifyDomainResponse = ({
    domain: string;
});

export type HandleVerifyDomainError = ({
    message: string;
});

export type HandleCreateDomainVerificationData = {
    body: FreestyleDomainVerificationRequest;
};

export type HandleCreateDomainVerificationResponse = (DomainVerificationRequest);

export type HandleCreateDomainVerificationError = ({
    message: string;
});

export type HandleDeleteDomainVerificationData = {
    body: FreestyleDeleteDomainVerificationRequest;
};

export type HandleDeleteDomainVerificationResponse = ({
    verificationCode: string;
    domain: string;
});

export type HandleDeleteDomainVerificationError = ({
    message: string;
});

export type HandleEphemeralDevServerData = {
    body: DevServerRequest;
};

export type HandleEphemeralDevServerResponse = ({
    /**
     * @deprecated
     */
    url: string;
    isNew: boolean;
    devCommandRunning: boolean;
    installCommandRunning: boolean;
    mcpEphemeralUrl?: (string) | null;
    ephemeralUrl?: (string) | null;
});

export type HandleEphemeralDevServerError = (InternalServerError);

export type HandleExecOnEphemeralDevServerData = {
    body: ExecRequest;
};

export type HandleExecOnEphemeralDevServerResponse = ({
    id: string;
    isNew: boolean;
    stdout?: Array<(string)> | null;
    stderr?: Array<(string)> | null;
});

export type HandleExecOnEphemeralDevServerError = (InternalServerError);

export type HandleWriteFileFromEphemeralDevServerData = {
    path: {
        /**
         * The path to the file to read from the dev server
         */
        filepath: string;
    };
};

export type HandleWriteFileFromEphemeralDevServerResponse = ({
    id: string;
    isNew: boolean;
});

export type HandleWriteFileFromEphemeralDevServerError = (InternalServerError);

export type HandleReadFileFromEphemeralDevServerData = {
    path: {
        /**
         * The path to the file to read from the dev server
         */
        filepath: string;
    };
};

export type HandleReadFileFromEphemeralDevServerResponse = ({
    id: string;
    isNew: boolean;
    content: ({
    content: string;
    encoding: string;
    kind: 'file';
} | {
    files: Array<(string)>;
    kind: 'directory';
});
});

export type HandleReadFileFromEphemeralDevServerError = ({
    id: string;
    isNew: boolean;
} | InternalServerError);

export type HandleGitCommitPushData = {
    body: GitCommitPushRequest;
};

export type HandleGitCommitPushResponse = ({
    id: string;
    isNew: boolean;
});

export type HandleGitCommitPushError = (InternalServerError);

export type HandleShutdownDevServerData = {
    body: ShutdownDevServerRequest;
};

export type HandleShutdownDevServerResponse = ({
    success: boolean;
    message: string;
});

export type HandleShutdownDevServerError = ({
    message: string;
} | InternalServerError);

export type HandleDevServerStatusData = {
    body: DevServerStatusRequest;
};

export type HandleDevServerStatusResponse = ({
    installing: boolean;
    devRunning: boolean;
});

export type HandleDevServerStatusError = (InternalServerError);

export type HandleWatchDevServerFilesData = {
    body: DevServerWatchFilesRequest;
};

export type HandleWatchDevServerFilesResponse = (string);

export type HandleWatchDevServerFilesError = unknown;

export type HandleListExecuteRunsData = {
    query?: {
        limit?: (number) | null;
        offset?: (number) | null;
    };
};

export type HandleListExecuteRunsResponse = ({
    entries: Array<ExecuteLogEntry>;
    total: number;
    offset: number;
});

export type HandleListExecuteRunsError = ({
    message: string;
});

export type HandleGetExecuteRunData = {
    path: {
        deployment: string;
    };
};

export type HandleGetExecuteRunResponse = ({
    metadata: ExecuteLogEntry;
    code?: (null | ExecuteRunInfo);
});

export type HandleGetExecuteRunError = ({
    message: string;
});

export type HandleExecuteScriptData = {
    body: FreestyleExecuteScriptParams;
};

export type HandleExecuteScriptResponse = ({
    /**
     * The return value of the default export of the script
     */
    result: unknown;
    logs: Array<FreestyleJavaScriptLog>;
});

export type HandleExecuteScriptError = ({
    error: string;
    logs?: Array<FreestyleJavaScriptLog> | null;
});

export type HandleListIdentitiesData = {
    query?: {
        includeManaged?: (boolean) | null;
        limit?: (number) | null;
        offset?: (number) | null;
    };
};

export type HandleListIdentitiesResponse = ({
    identities: Array<GitIdentity>;
    offset: number;
    total: number;
});

export type HandleListIdentitiesError = ({
    message: string;
});

export type HandleCreateIdentityResponse = (GitIdentity);

export type HandleCreateIdentityError = ({
    message: string;
});

export type HandleDeleteIdentityData = {
    path: {
        identity: string;
    };
};

export type HandleDeleteIdentityResponse = ({
    [key: string]: unknown;
});

export type HandleDeleteIdentityError = ({
    message: string;
});

export type HandleListPermissionsData = {
    path: {
        identity: string;
    };
    query?: {
        /**
         * Maximum number of repositories to return
         */
        limit?: number;
        /**
         * Offset for the list of repositories
         */
        offset?: number;
    };
};

export type HandleListPermissionsResponse = (ListPermissionResponseSuccess);

export type HandleListPermissionsError = ({
    message: string;
});

export type HandleDescribePermissionData = {
    path: {
        identity: string;
        repo: string;
    };
};

export type HandleDescribePermissionResponse = (DescribePermissionResponseSuccess);

export type HandleDescribePermissionError = ({
    message: string;
});

export type HandleGrantPermissionData = {
    body: GrantPermissionRequest;
    path: {
        identity: string;
        repo: string;
    };
};

export type HandleGrantPermissionResponse = ({
    [key: string]: unknown;
});

export type HandleGrantPermissionError = ({
    message: string;
});

export type HandleRevokePermissionData = {
    path: {
        identity: string;
        repo: string;
    };
};

export type HandleRevokePermissionResponse = ({
    [key: string]: unknown;
});

export type HandleRevokePermissionError = ({
    message: string;
});

export type HandleUpdatePermissionData = {
    body: UpdatePermissionRequest;
    path: {
        identity: string;
        repo: string;
    };
};

export type HandleUpdatePermissionResponse = ({
    [key: string]: unknown;
});

export type HandleUpdatePermissionError = ({
    message: string;
});

export type HandleListGitTokensData = {
    path: {
        identity: string;
    };
};

export type HandleListGitTokensResponse = (ListGitTokensResponseSuccess);

export type HandleListGitTokensError = ({
    message: string;
});

export type HandleCreateGitTokenData = {
    path: {
        identity: string;
    };
};

export type HandleCreateGitTokenResponse = (CreatedToken);

export type HandleCreateGitTokenError = ({
    message: string;
});

export type HandleRevokeGitTokenData = {
    body: RevokeGitTokenRequest;
    path: {
        identity: string;
    };
};

export type HandleRevokeGitTokenResponse = ({
    [key: string]: unknown;
});

export type HandleRevokeGitTokenError = ({
    message: string;
});

export type HandleListRepositoriesData = {
    query?: {
        /**
         * Maximum number of repositories to return
         */
        limit?: number;
        /**
         * Offset for the list of repositories
         */
        offset?: number;
    };
};

export type HandleListRepositoriesResponse = ({
    repositories: Array<RepositoryMetadata>;
    total: number;
    offset: number;
});

export type HandleListRepositoriesError = ({
    message: string;
});

export type HandleCreateRepoData = {
    body: {
        /**
         * This name is not visible to users, and is only accessible to you via API and in the
         * dashboard. Mostly useful for observability.
         */
        name?: (string) | null;
        public?: boolean;
        /**
         * The default branch name for the repository. Defaults to "main" if not specified.
         */
        defaultBranch?: (string) | null;
        /**
         * Fork from another Git repository. Cannot be used with `import`.
         */
        source?: CreateRepoSource;
        /**
         * Import static content with an initial commit. Cannot be used with `source`.
         */
        import?: CreateRepoImport;
    };
};

export type HandleCreateRepoResponse = (CreateRepositoryResponseSuccess);

export type HandleCreateRepoError = ({
    message: string;
});

export type HandleGetDefaultBranchData = {
    path: {
        /**
         * The repository ID
         */
        repo_id: string;
    };
};

export type HandleGetDefaultBranchResponse = (GetDefaultBranchResponse);

export type HandleGetDefaultBranchError = unknown;

export type HandleSetDefaultBranchData = {
    body: SetDefaultBranchRequest;
    path: {
        /**
         * The repository ID
         */
        repo_id: string;
    };
};

export type HandleSetDefaultBranchResponse = (SetDefaultBranchResponse);

export type HandleSetDefaultBranchError = unknown;

export type GetGithubSyncData = {
    path: {
        /**
         * Repository ID
         */
        repo_id: string;
    };
};

export type GetGithubSyncResponse = (GithubSyncConfigResponse);

export type GetGithubSyncError = (unknown);

export type ConfigureGithubSyncData = {
    body: ConfigureGithubSyncRequest;
    path: {
        /**
         * Repository ID
         */
        repo_id: string;
    };
};

export type ConfigureGithubSyncResponse = (unknown);

export type ConfigureGithubSyncError = (unknown);

export type RemoveGithubSyncData = {
    path: {
        /**
         * Repository ID
         */
        repo_id: string;
    };
};

export type RemoveGithubSyncResponse = (unknown);

export type RemoveGithubSyncError = (unknown);

export type HandleGetRepoInfoData = {
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
};

export type HandleGetRepoInfoResponse = (RepositoryInfo);

export type HandleGetRepoInfoError = (unknown);

export type HandleDeleteRepoData = {
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
};

export type HandleDeleteRepoResponse = ({
    [key: string]: unknown;
});

export type HandleDeleteRepoError = ({
    message: string;
} | {
    [key: string]: unknown;
});

export type HandleGetContentsData = {
    path: {
        /**
         * The path to the file or directory. Empty for root.
         */
        path: (string) | null;
        /**
         * The repository ID.
         */
        repo: string;
    };
    query?: {
        /**
         * The git reference (branch name, commit SHA, etc.). Defaults to HEAD.
         */
        ref?: string;
    };
};

export type HandleGetContentsResponse = (GitContents);

export type HandleGetContentsError = ({
    message: string;
});

export type HandleGetBlobData = {
    path: {
        /**
         * The object's hash
         */
        hash: string;
        /**
         * The repository id
         */
        repo: string;
    };
};

export type HandleGetBlobResponse = (BlobObject);

export type HandleGetBlobError = ({
    message: string;
});

export type HandleListCommitsData = {
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: {
        /**
         * Branch name (defaults to HEAD)
         */
        branch?: (string) | null;
        /**
         * Maximum number of commits to return (default: 50, max: 500)
         */
        limit?: (number) | null;
        /**
         * Number of commits to skip (default: 0)
         */
        offset?: (number) | null;
    };
};

export type HandleListCommitsResponse = (CommitList);

export type HandleListCommitsError = ({
    message: string;
});

export type HandleGetCommitData = {
    path: {
        /**
         * The object's hash
         */
        hash: string;
        /**
         * The repository id
         */
        repo: string;
    };
};

export type HandleGetCommitResponse = (CommitObject);

export type HandleGetCommitError = ({
    message: string;
});

export type HandleGetRefBranchData = {
    path: {
        /**
         * The branch's name
         */
        branch: string;
        /**
         * The repository id
         */
        repo: string;
    };
};

export type HandleGetRefBranchResponse = (GitReference);

export type HandleGetRefBranchError = (unknown | {
    message: string;
});

export type HandleGetRefTagData = {
    path: {
        /**
         * The repository id
         */
        repo: string;
        /**
         * The tag's name
         */
        tag: string;
    };
};

export type HandleGetRefTagResponse = (GitReference);

export type HandleGetRefTagError = (unknown | {
    message: string;
});

export type HandleGetTagData = {
    path: {
        /**
         * The object's hash
         */
        hash: string;
        /**
         * The repository id
         */
        repo: string;
    };
};

export type HandleGetTagResponse = (TagObject);

export type HandleGetTagError = ({
    message: string;
});

export type HandleGetTreeData = {
    path: {
        /**
         * The object's hash
         */
        hash: string;
        /**
         * The repository id
         */
        repo: string;
    };
};

export type HandleGetTreeResponse = (TreeObject);

export type HandleGetTreeError = ({
    message: string;
});

export type HandleDownloadTarballData = {
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: {
        /**
         * The git reference (branch name, commit SHA, etc.). Defaults to HEAD.
         */
        ref?: string;
    };
};

export type HandleDownloadTarballResponse = (unknown);

export type HandleDownloadTarballError = ({
    message: string;
});

export type HandleListGitTriggersData = {
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
};

export type HandleListGitTriggersResponse = ({
    triggers: Array<GitRepositoryTrigger>;
});

export type HandleListGitTriggersError = ({
    message: string;
});

export type HandleCreateGitTriggerData = {
    body: {
        trigger: ({
    branches?: Array<(string)> | null;
    globs?: Array<(string)> | null;
    event: 'push';
});
        action: ({
    endpoint: string;
    action: 'webhook';
});
    };
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
};

export type HandleCreateGitTriggerResponse = ({
    triggerId: string;
});

export type HandleCreateGitTriggerError = ({
    message: string;
});

export type HandleDeleteGitTriggerData = {
    path: {
        /**
         * The repository id
         */
        repo: string;
        /**
         * The trigger id
         */
        trigger: string;
    };
};

export type HandleDeleteGitTriggerResponse = ({
    [key: string]: unknown;
});

export type HandleDeleteGitTriggerError = ({
    message: string;
} | {
    [key: string]: unknown;
});

export type HandleDownloadZipData = {
    path: {
        /**
         * The repository id
         */
        repo: string;
    };
    query?: {
        /**
         * The git reference (branch name, commit SHA, etc.). Defaults to HEAD.
         */
        ref?: string;
    };
};

export type HandleDownloadZipResponse = (unknown);

export type HandleDownloadZipError = ({
    message: string;
});

export type HandleGetLogsData = {
    query?: {
        deploymentId?: (string) | null;
        domain?: (string) | null;
    };
};

export type HandleGetLogsResponse = (FreestyleGetLogsResponse);

export type HandleGetLogsError = unknown;

export type HandleDeployWebData = {
    body: FreestyleDeployWebPayload;
};

export type HandleDeployWebResponse = (FreestyleDeployWebSuccessResponseV2);

export type HandleDeployWebError = (FreestyleDeployWebErrorResponse);

export type HandleDeployWebV2Data = {
    body: FreestyleDeployWebPayloadV2;
};

export type HandleDeployWebV2Response = (FreestyleDeployWebSuccessResponseV2);

export type HandleDeployWebV2Error = (FreestyleDeployWebErrorResponse);

export type HandleListWebDeploysData = {
    query: {
        /**
         * Maximum number of repositories to return
         */
        limit: number;
        /**
         * Offset for the list of repositories
         */
        offset: number;
    };
};

export type HandleListWebDeploysResponse = ({
    entries: Array<DeploymentLogEntry>;
    total: number;
    offset: number;
});

export type HandleListWebDeploysError = ({
    message: string;
});

export type HandleGetWebDeployDetailsData = {
    path: {
        deployment_id: string;
    };
};